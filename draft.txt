################    draft here

2020.03.01

    #用ECS的机制来实现isometric
    1.新增IsometricPosComponent{x, y}，类似于posCom
    2.提供相应的IsometricPosSystem，推导出IsometricPosTuple{posCom, isoPosCom}
    3.每tick只需根据posCom计算isoPosCom

    #单位何时拥有isoPosCom?
    在配置数据中：
        layer : { 
            tilemap : {
                datas : [1, 1, 3, 2]
            }
    在自定义的callback(tag)中，假设"3"对应数据:
        {render-type: 'isometric-enum'}

    #另一种方案：ViewCom中加入isometrics相关属性：
        viewCom : { isometricFlag : true }
        renderTuple : { viewCom, displayObject, pos, offset }
        renderUpdateSystem中处理，得到isometricPos


2020.03.02

    #Gridmap改造
        gridMap的定位，是一个二元容器，扩展用法有tilemap, quadtree等
        因此抽象方法：setData, getData, getGrid等

2020.03.04

    #rect, pos, offset的关系架构问题
        方案1：定义一个基类：PosOffsetTuple，子类为：RectPosTuple, DisplayTuple等
            这样，在计算rect-cross时，直接使用本对象即可
        方案2：PosOffsetTuple（子类RectPosTuple）, 只是作为VO类，被其他元件拥有，如Collider, DisplayTuple等
        思考：方案1会回到OOP的怪圈中

2020.03.06
    引入event机制
        engine-init时，需要传入onTouch, onKey等callback
        tilemap-init时，需要传入onCreate-callback
        这样造成函数的参数过长过多，而且callback规范不一，可读性差
        设计统一的event机制，使engine, tilemap等init时发送事件即可
        main.js处自行addEventListener来处理

    框架组件的归属
        既然director负责调度所有资源的运行，就不应依赖于lib
        engine, action等均属于组件，在未成熟前，暂时将其归类在lib中
        框架最终分成——基础层、调度层、实现库层

    iso转换机制
        期望：iso的处理是对用户透明的
        目前，iso封装在viewCom中，在renderSys中统一处理
        没有screen-pos到iso-world的转换，不建议暴露转换接口到外部，思考如何内部消化

2020.03.10
	要像用户一样，思考ide编辑器的操作
	如，拖动gird块造成大量填充，n * m的格子计算